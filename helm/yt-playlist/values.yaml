# Default values for yt-playlist Helm chart

image:
  repository: ghcr.io/l4r5/yt-playlist
  tag: ""  # Defaults to Chart.AppVersion (1.0.8), override with --set image.tag=x.y.z
  pullPolicy: IfNotPresent

# Deployment configuration
replicaCount: 1

# Service (for metrics endpoint)
service:
  enabled: true  # Metrics endpoint is available on port 8080
  type: ClusterIP
  port: 8080
  annotations: {}

# ServiceMonitor for Prometheus Operator
serviceMonitor:
  enabled: false  # Requires Prometheus Operator CRDs
  interval: 30s
  path: /metrics
  scrapeTimeout: 10s
  additionalLabels: {}
  # additionalLabels:
  #   prometheus: kube-prometheus
  relabelings: []
  metricRelabelings: []

# Ingress (not typically needed for background daemon)
ingress:
  enabled: false
  className: ""  # Use cluster default ingress controller, or specify: nginx, traefik, haproxy, etc.
  annotations:
    # For automatic certificate management with cert-manager
    cert-manager.io/cluster-issuer: letsencrypt-prod
    # For NGINX-specific settings
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # For larger body size (video uploads)
    nginx.ingress.kubernetes.io/proxy-body-size: "100m"
  hosts:
    - host: yt-playlist.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: yt-playlist-tls  # TLS certificate secret
      hosts:
        - yt-playlist.example.com
  # Alternative: Multiple domains with separate certificates
  # tls:
  #   - secretName: yt-playlist-prod-tls
  #     hosts:
  #       - yt-playlist.example.com
  #       - www.yt-playlist.example.com
  #   - secretName: yt-playlist-metrics-tls
  #     hosts:
  #       - metrics.yt-playlist.example.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 100m
    memory: 256Mi

# OAuth2 authentication
# Option 1: Provide client secret JSON directly (for initial setup)
# clientSecretJson: '{"installed":{"client_id":"...","client_secret":"...","redirect_uris":["http://localhost"]}}'

# Option 2: Reference existing secret containing client_secret.json and/or token.json
# existingSecret: yt-playlist-oauth-credentials
# When using existingSecret, the secret must contain:
#   - CLIENT_SECRET_JSON: base64 encoded OAuth2 client credentials JSON
#   - token.json: (optional) base64 encoded OAuth2 token after authentication

# OAuth2 credentials secret name (auto-generated if not using existingSecret)
secretName: yt-playlist-credentials

# YouTube playlist configuration (REQUIRED)
playlists:
  # Source playlist with videos to download
  todoPlaylistId: ""
  # Destination playlist for completed downloads
  donePlaylistId: ""

# Download configuration
download:
  # Download mode: 'video' (full video) or 'audio' (audio-only)
  mode: video
  # Poll interval in seconds (how often to check for new videos)
  pollInterval: 300
  # YouTube cookies for bot detection bypass (use ONE method):
  # Method 1: Path to cookies.txt file (if mounted as volume)
  cookiesFile: ""
  # Method 2: Cookies content as string (recommended - store in secret)
  cookiesContent: ""

# Logging configuration
logging:
  # Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL
  level: INFO
  # Log file path (container filesystem)
  file: /tmp/playlist_manager.log

# Tailscale VPN sidecar (routes traffic through your home network)
tailscale:
  enabled: false  # Enable to route YouTube traffic through home IP
  image:
    repository: tailscale/tailscale
    tag: latest
    pullPolicy: IfNotPresent
  # Tailscale auth key (from https://login.tailscale.com/admin/settings/keys)
  # Option 1: Set directly (not recommended for production)
  authKey: ""
  # Option 2: Reference existing secret
  existingSecret: ""  # Name of secret containing 'TS_AUTHKEY'
  # Exit node configuration
  exitNode: ""  # Tailscale hostname or IP of exit node (e.g., "home-server")
  # Accept routes from exit node
  acceptRoutes: true
  # Additional Tailscale arguments
  extraArgs: []
  # Example: ["--advertise-tags=tag:k8s", "--hostname=yt-playlist-pod"]
  # Additional tailscaled daemon arguments (passed to TS_TAILSCALED_EXTRA_ARGS)
  tailscaledExtraArgs: ""
  # Example: "--verbose=1" or "--debug=" for debugging
  # HTTP proxy configuration (for Tailscale to reach control server through proxy)
  proxy:
    enabled: false
    httpProxy: ""   # e.g., "http://proxy.example.com:8080"
    httpsProxy: ""  # e.g., "http://proxy.example.com:8080"
    noProxy: ""     # e.g., "localhost,127.0.0.1,.svc,.cluster.local"
  resources:
    requests:
      memory: "50Mi"
      cpu: "50m"
    limits:
      memory: "200Mi"
      cpu: "200m"

# Persistent storage for downloaded videos
persistence:
  enabled: true
  storageClass: ""  # Use default storage class if empty
  accessMode: ReadWriteOnce
  size: 50Gi
  # Existing PVC name (if you want to use pre-created PVC)
  existingClaim: ""
  # Retention policy: 'delete' (default) or 'keep'
  # When set to 'keep', PVC will not be deleted when Helm release is uninstalled
  retain: false  # Set to true to keep data after app deletion
  # SubPath within the volume (useful for sharing PVC between multiple apps/environments)
  subPath: ""  # e.g., "production", "dev", "tenant-a"

# Service account
serviceAccount:
  create: true
  name: ""
  annotations: {}

# Pod annotations
podAnnotations: {}

# Pod security context
podSecurityContext:
  fsGroup: 1000  # Group ID for volume ownership

# Container security context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000  # User ID to run container as
  runAsGroup: 1000  # Group ID to run container as
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Initial authentication job
auth:
  # Enable authentication job for first-time OAuth setup
  enabled: false
  # Service type for OAuth callback (use NodePort or LoadBalancer for external access)
  serviceType: ClusterIP
  # NodePort for OAuth callback (only used if serviceType is NodePort)
  nodePort: 30080
  
  # Web UI for OAuth authentication (recommended)
  ui:
    enabled: false
    # Optional: Explicit redirect URI for OAuth (required when using ingress)
    # Example: https://auth.example.com/callback
    redirectUri: ""
    image:
      repository: ghcr.io/l4r5/yt-playlist-auth-ui
      tag: ""  # Defaults to Chart.AppVersion, override with --set auth.ui.image.tag=x.y.z
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
      requests:
        cpu: 50m
        memory: 128Mi
    service:
      type: ClusterIP  # Use LoadBalancer or NodePort for external access
      nodePort: null  # Set if using NodePort
    ingress:
      enabled: false
      className: ""  # Use cluster default ingress controller, or specify: nginx, traefik, haproxy, etc.
      annotations:
        # For automatic certificate management with cert-manager
        cert-manager.io/cluster-issuer: letsencrypt-prod
        # For NGINX-specific settings
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        # Session affinity for OAuth flow
        nginx.ingress.kubernetes.io/affinity: "cookie"
        nginx.ingress.kubernetes.io/session-cookie-name: "auth-session"
        nginx.ingress.kubernetes.io/session-cookie-max-age: "3600"
      hosts:
        - host: auth.yt-playlist.example.com
          paths:
            - path: /
              pathType: Prefix
      tls:
        - secretName: yt-playlist-auth-tls  # TLS certificate secret
          hosts:
            - auth.yt-playlist.example.com
      # Alternative: Wildcard certificate
      # tls:
      #   - secretName: wildcard-yt-playlist-tls
      #     hosts:
      #       - auth.yt-playlist.example.com
      #       - app.yt-playlist.example.com
