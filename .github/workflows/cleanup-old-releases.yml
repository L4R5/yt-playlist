name: Cleanup Old Releases and Images

on:
  workflow_run:
    workflows: ["Build and Push Docker Image", "Build and Push Auth UI Docker Image"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      keep_count:
        description: 'Number of releases to keep'
        required: false
        default: '10'
        type: string

env:
  REGISTRY: ghcr.io
  KEEP_COUNT: ${{ github.event.inputs.keep_count || '10' }}

jobs:
  cleanup-releases:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: Cleanup old releases
        uses: actions/github-script@v8
        with:
          script: |
            const keepCount = parseInt(process.env.KEEP_COUNT);
            console.log(`Keeping the latest ${keepCount} releases`);
            
            // Get all releases, sorted by creation date (newest first)
            const releases = await github.paginate(
              github.rest.repos.listReleases,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );
            
            console.log(`Found ${releases.length} total releases`);
            
            // Delete old releases (beyond keepCount)
            const releasesToDelete = releases.slice(keepCount);
            console.log(`Deleting ${releasesToDelete.length} old releases`);
            
            for (const release of releasesToDelete) {
              console.log(`Deleting release: ${release.name || release.tag_name} (ID: ${release.id})`);
              try {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id
                });
                
                // Also delete the associated tag
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${release.tag_name}`
                  });
                  console.log(`Deleted tag: ${release.tag_name}`);
                } catch (tagError) {
                  console.log(`Could not delete tag ${release.tag_name}: ${tagError.message}`);
                }
              } catch (error) {
                console.log(`Failed to delete release ${release.id}: ${error.message}`);
              }
            }

  cleanup-container-images:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    strategy:
      matrix:
        image: ['yt-playlist', 'yt-playlist-auth-ui']
    
    steps:
      - name: Cleanup old container images for ${{ matrix.image }}
        uses: actions/github-script@v8
        with:
          script: |
            const keepCount = parseInt(process.env.KEEP_COUNT);
            const imageName = '${{ matrix.image }}';
            console.log(`Processing ${imageName}: keeping latest ${keepCount} versions`);
            
            try {
              // Get all versions of the package
              // Try organization API first, fall back to user API
              let versions;
              try {
                versions = await github.paginate(
                  github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg,
                  {
                    package_type: 'container',
                    package_name: imageName,
                    org: context.repo.owner,
                    per_page: 100
                  }
                );
              } catch (orgError) {
                if (orgError.status === 404) {
                  // Not an organization, try user API
                  console.log(`Not an organization, trying user API`);
                  versions = await github.paginate(
                    github.rest.packages.getAllPackageVersionsForPackageOwnedByUser,
                    {
                      package_type: 'container',
                      package_name: imageName,
                      username: context.repo.owner,
                      per_page: 100
                    }
                  );
                } else {
                  throw orgError;
                }
              }
              
              console.log(`Found ${versions.length} total versions for ${imageName}`);
              
              // Separate tagged and untagged versions
              const taggedVersions = [];
              const untaggedVersions = [];
              
              for (const version of versions) {
                const tags = version.metadata?.container?.tags || [];
                if (tags.length > 0) {
                  taggedVersions.push(version);
                } else {
                  untaggedVersions.push(version);
                }
              }
              
              console.log(`Tagged versions: ${taggedVersions.length}, Untagged versions: ${untaggedVersions.length}`);
              
              // Phase 1: Delete ALL untagged versions (orphaned images)
              console.log(`Phase 1: Deleting all ${untaggedVersions.length} untagged versions...`);
              for (const version of untaggedVersions) {
                console.log(`Deleting untagged version ID ${version.id} (created: ${version.created_at})`);
                try {
                  await github.rest.packages.deletePackageVersionForOrg({
                    package_type: 'container',
                    package_name: imageName,
                    org: context.repo.owner,
                    package_version_id: version.id
                  });
                  console.log(`✓ Deleted untagged version ${version.id}`);
                } catch (deleteError) {
                  if (deleteError.status === 404) {
                    await github.rest.packages.deletePackageVersionForUser({
                      package_type: 'container',
                      package_name: imageName,
                      username: context.repo.owner,
                      package_version_id: version.id
                    });
                    console.log(`✓ Deleted untagged version ${version.id} (user API)`);
                  } else {
                    console.log(`✗ Failed to delete version ${version.id}: ${deleteError.message}`);
                  }
                }
              }
              
              // Phase 2: Keep latest N tagged versions, delete older ones
              taggedVersions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const taggedToDelete = taggedVersions.slice(keepCount);
              const taggedToKeep = taggedVersions.slice(0, keepCount);
              
              console.log(`Phase 2: Keeping ${taggedToKeep.length} latest tagged versions, deleting ${taggedToDelete.length} old tagged versions`);
              
              for (const version of taggedToDelete) {
                const tags = version.metadata?.container?.tags || [];
                const tagStr = tags.join(', ');
                console.log(`Deleting old tagged version ID ${version.id} (tags: ${tagStr}, created: ${version.created_at})`);
                
                try {
                  await github.rest.packages.deletePackageVersionForOrg({
                    package_type: 'container',
                    package_name: imageName,
                    org: context.repo.owner,
                    package_version_id: version.id
                  });
                  console.log(`✓ Deleted tagged version ${version.id}`);
                } catch (deleteError) {
                  if (deleteError.status === 404) {
                    await github.rest.packages.deletePackageVersionForUser({
                      package_type: 'container',
                      package_name: imageName,
                      username: context.repo.owner,
                      package_version_id: version.id
                    });
                    console.log(`✓ Deleted tagged version ${version.id} (user API)`);
                  } else {
                    console.log(`✗ Failed to delete version ${version.id}: ${deleteError.message}`);
                  }
                }
              }
              
              console.log(`Cleanup complete for ${imageName}`);
              console.log(`Summary: Deleted ${untaggedVersions.length} untagged + ${taggedToDelete.length} old tagged versions`);
              console.log(`Keeping ${taggedToKeep.length} tagged versions with tags: ${taggedToKeep.map(v => v.metadata?.container?.tags?.join(',') || 'unknown').join(', ')}`);
            } catch (error) {
              if (error.status === 404) {
                console.log(`Package ${imageName} not found - may not exist yet`);
              } else {
                throw error;
              }
            }
